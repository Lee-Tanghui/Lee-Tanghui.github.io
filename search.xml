<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-router4更新踩坑]]></title>
    <url>%2F2017%2F08%2F14%2FreactRouterChange%2F</url>
    <content type="text"><![CDATA[###一.前言 上午把近日用React做的一个新闻项目所依赖的包升级到了最新的版本,其中从react-router(2.8.1)升级到react-router(4.1.2)中出现了很多问题, 故总结一下在升级过程中遇到的问题. ###二.react-router,V4版本修改内容 ####1. 所有组件更改为从react-router-dom导入 之前的所有路由组件均是从react-router中导入,在我之前的项目中,导入相关组件如下:12//v2import &#123;Router,Route,hashHistory&#125; from 'react-router'; 在react-router4 开始,所有的router组件均是从react-router-dom中导入, 所以一下的需要更改为以下代码:12//v4import &#123;Route,BrowserRouter, Switch&#125; from 'react-router-dom'; 细心的你发现在,到导入的过程中,我删除了Router,但是增加了BorwerRouter和Switch,下面我会一步步的说明. ####2. 将所有&lt;Router&gt;替换为&lt;BrowserRouter&gt;之前v2中的代码如下:123456//v2 &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;PCIndex&#125;&gt;&lt;/Route&gt; &lt;Route path="/details/:uniqueky" component=&#123;PCNewsDetails&#125;&gt;&lt;/Route&gt; &lt;Route path="/usercenter" component=&#123;PCUserCenter&#125;&gt;&lt;/Route&gt; &lt;/Router&gt; 现在需要更改为BrowserRouter12345678//v4&lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;MobileIndex&#125;&gt;&lt;/Route&gt; &lt;Route path="/details/:uniqueky" component=&#123;MobileNewsDetails&#125;&gt;&lt;/Route&gt; &lt;Route path="/usercenter" component=&#123;MobileUserCenter&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; 细心的你发现,这里的代码不仅仅是将Router替换为BrowserRouter,而且还把所有的Route中用Switch包裹起来. 下面就是v4的另一个修改. ####3. &lt;BrowserRouter&gt;只能有一个子节点&lt;BroserRouter&gt;只能有一个子节点,所以官网建议的是使用&lt;Switch&gt;进行包裹,官网给出的例子如下. In v3, you could specify a number of child routes, and only the first one that matched would be rendered.123456// v3&lt;Route path='/' component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path='about' component=&#123;About&#125; /&gt; &lt;Route path='contact' component=&#123;Contact&#125; /&gt;&lt;/Route&gt; v4 provides a similar functionality with the component. When a is rendered, it will only render the first child that matches the current location.12345678// v4const App = () =&gt; ( &lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125; /&gt; &lt;Route path='/about' component=&#123;About&#125; /&gt; &lt;Route path='/contact' component=&#123;Contact&#125; /&gt; &lt;/Switch&gt;) ####4. 最坑的地方:在当前目录下的文件路径不再使用./, 而是直接用/.在进行文件引用的时候 ,./src/js的写法需要更改文’/src/js’, 这是更改之后最坑的地方!!! 因为其他的更改,在控制台都会有着详细的错误提示, 然而找不到文件只会出现404!!!我真的找了好久的原因!!! 记住!!! 在单页面中的引入的css文件和bundle.js的引入都需要更改, 在我的项目中的例子如下: 1234567891011121314151617//v2&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="./src/css/pc.css"&gt; &lt;link rel="stylesheet" href="./src/css/mobile.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="mainContainer"&gt; &lt;/div&gt; &lt;script src="./src/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的页面需要更改为下面这样,否则所有的文件都无法找到:1234567891011121314151617//v4&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="/src/css/pc.css"&gt; &lt;link rel="stylesheet" href="/src/css/mobile.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="mainContainer"&gt; &lt;/div&gt; &lt;script src="/src/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ###三.更多信息以上就是我在我的项目中所遇到的坑,以及对应的处理办法.总的来说react-router4 rewrite之后变化还是挺大的. 1. 更多React-router v4的修改信息,请看Github: Migrating from v2/v3 to v4 2. 本文中的项目下载地址: Github: https://github.com/Lee-Tanghui/React-news-project.git]]></content>
  </entry>
  <entry>
    <title><![CDATA[React环境配置 & Webpack实现热加载]]></title>
    <url>%2F2017%2F08%2F08%2Fwebpack%2F</url>
    <content type="text"><![CDATA[一.React环境配置1.1 配置前的准备 新建一个空文件夹,命名为项目名.点击文件夹,进入根目录下 在项目文件夹的根目录下开启命令行, window操作系统为在根目录下 shift + 鼠标右键, 再点击 open command window(打开window命令行工具) 注意: 以下的操作都是在项目文件夹的根目录下的cmd中进行操作. 考虑到下载包的效率, 下载的操作我这里全部使用的cnpm, 同样可以使用npm. cnpm为npm的淘宝镜像http://npm.taobao.org/ 1.2 初始化 package.json 配置文件在命令行输入以下命令 npm init 点击Enter之后,会出现包的一些配置参数,根据需求设置即可. 最后出现Is this ok?,输入yes,就可以看见出现了一个 package.json 文件.该配置文件为包的目录文件. 1.3 安装React和React-DOM在命令行输入以下命令 cnpm install –save react react-dom 1.4 安装babel及其依赖在命令行输入以下命令 cnpm install babel-preset-es2015 babelify babel-preset-react babel-plugin-react-html-attrs babel-loader –save 1.5 React和Babel安装完成后的目录如下 此时可以看到,项目文件夹内有了 node_modules 这个文件夹, 且 package.json 这个文件中,也有了我们安装的 react 和 babel 的包. 二.webpack安装2.1 在全局下安装webpack在命令行下输入以下命令 cnpm install -g webpack 2.2 在全局下安装webpack-dev-server1. 在命令行下输入以下命令 cnpm install -g webpack-dev-server 2. 如果安装时出现:Error: EPERM: operation not permitted, mkdir &#39;C:\Program Files\nodejs\node_modules\webpack-dev-server_tmp&#39; at Error (native)报错信息,请使用windows + x 使用admin权限进行安装 2.3 在项目根目录下下安装webpack在命令行下输入以下命令 cnpm install webpack –save 2.4 在项目根目录安装webpack-dev-server1. 在命令行下输入以下命令 cnpm install webpack-dev-server –save 2. 如果安装时出现:Error: EPERM: operation not permitted, mkdir &#39;C:\Program Files\nodejs\node_modules\webpack-dev-server_tmp&#39; at Error (native)报错信息,请使用windows + x 使用admin权限进行安装 2.5 Webpack安装完成后的目录如下 此时可以看到我们的 package.json文件中对添加了webpack和webpack-dev-server的的包. 三.实现webpack热加载(以Hello World!举例)3.1 在根目录下新建index.html index.html中内容如下 12&lt;div id=&quot;example&quot;&gt;我是主页&lt;/div&gt;&lt;script src=&quot;./src/bundle.js&quot;&gt;&lt;/script&gt; 这里的bundle.js是随后webpack打包后生成的文件. 此时打开index.html,效果如下 3.2 新建index.js用作入口文件 在根目录下新建src文件夹 在src文件夹下新建js文件夹 在js文件夹下新建index.js文件, index.js内容如下 1234567var React = require(&apos;react&apos;);var ReactDOM = require(&apos;react-dom&apos;);ReactDOM.render( &lt;h1&gt;Hello World!&lt;/h1&gt;, document.getElementById(&apos;example&apos;)) 3.3 在根目录下新建webpack.config.js webpack.config.js中内容如下 123456789101112131415161718192021222324252627282930313233var debug = process.env.NODE_ENV !== &quot;production&quot;;var webpack = require(&apos;webpack&apos;);var path = require(&apos;path&apos;);module.exports = &#123; context: path.join(__dirname), devtool: debug ? &quot;inline-sourcemap&quot; : null, entry: &quot;./src/js/index.js&quot;, //这里是入口文件地址,可根据自身的位置进行修改 module: &#123; loaders: [ &#123; test: /\.js?$/, exclude: /(node_modules)/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;react&apos;, &apos;es2015&apos;], plugins: [&apos;react-html-attrs&apos;], //添加组件的插件配置 &#125; &#125;, //下面是使用 ant-design 的配置文件 &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125; ] &#125;, output: &#123; path: __dirname, filename: &quot;./src/bundle.js&quot; &#125;, plugins: debug ? [] : [ new webpack.optimize.DedupePlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(&#123; mangle: false, sourcemap: false &#125;), ],&#125;; 此时文件目录如下: 3.4 利用webpack打包 再命令行中输入以下命令,注意在根目录下输入 webpack 此时可以看到src文件夹下自动生成了bundle.js 重新打开index.html, 可以看到,页面已经被渲染成Hello World! 3.5 实现Webpack热加载Q: 为什么要实现热加载? 如果每次在文件中进行了操作, 那么需要每次在命令行中输入webpack进行编译后才能够在浏览器中看到效果. 这也就是为什么要实现热加载的原因.webpack-dev-server会帮我们创建一个本地服务器,我们在编辑器中编辑后,就能实时的在浏览器中看到效果 热加载: 在命令行中输入以下命令 webpack-dev-server –inline –hot 此时webpack-dev-server会监听8080端口,我们在编辑器中进行的操作,就可以实时加载到localhost:8080上! 本例中的源文件下载地址: 百度网盘: https://pan.baidu.com/s/1o8Bhm3o 密码: 3ttf GitHub: https://github.com/Lee-Tanghui/React-init.git]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解原型、原型链、继承]]></title>
    <url>%2F2017%2F07%2F26%2Finherit%2F</url>
    <content type="text"><![CDATA[一. 构造函数,原型,实例三者的关系1. 构造函数:构造函数是创建对象的一种常用方式, 其他创建对象的方式还包括工厂模式, 原型模式, 对象字面量等.我们来看一个简单的构造函数:1234function Product (name, role)&#123; //构造函数的命名约定第一个字母使用大写的形式! this.name = name; this.role = role;&#125; ( 1 ) 每一个构造函数都有一个prototype属性,我们可以在Chorme控制台中打印出Product.prototype属性. ( 2 ) 通过控制台答应出的结果可以发现,Product.prototype属性其实是一个指针,指向一个对象, 该对象拥有一个constructor属性.( __proto__属性是浏览器引入的非标准属性,方便开发者调试用的,可以不予理会!)( 3 ) 所以,构造函数中的prototype属性指向一个对象, 该对象就是我们接下来要说的原型 2. 原型《Javascript高级程序设计》中是这样描述原型这个概念的: 无论什么时候, 只要创建一个新函数, 就会根据一组特定的规则为该函数创建一个prototype属性, 这个属性指向函数的原型对象. 在默认情况下, 所有原型对象都会自动获得一个constructor()构造函数属性,这个属性包含一个指向prototype属性所在函数的指针. 我相信看完这句话的你是懵逼的,下面我来解释一下这句话: ( 1 ) 构造函数的prototype属性所指向的对象我们将其称为原型( 2 ) 原型这个对象中,有一个constructor属性又指回其构造函数本身.( 3 ) 下面的图二,可以更清晰的弄明白两者之间的关系. 3. 实例通过构造函数创建对象的过程我们称之为实例化，创建出来的对象称为实例．现在我们通过我们的Product这个构造函数创建一个实例(对象).123456function Product (name, role)&#123; this.name = name; this.role = role;&#125;var p1 = new Product('apple', 'fruit'); ( 1 ) 现在我们来为原型添加一个方法123Product.prototype.greet = function()&#123; console.log('我是一个很甜的'+ this.name +', 买我!')&#125; ( 2 ) 在实例中调用该方法1p1.greet(); //我是一个很甜的apple, 买我! 可以看到,我们在原型中添加的方法,同时实例是可以使用的. 所以,我们可以得出以下结论: 原型里面的所有属性和方法会连接到其对应的构造函数的实例上 ! ( 3 ) 构造/实例/原型三角形通过下面的构造/实例/原型三角形可以更好的理解三者之间的关系: ４. 结论 站在构造函数角度看: 函数名.prototype这个对象是构造函数的原型属性 站在实例对象角度看: 函数名.prototype这个对象是实例对象的原型对象 原型式继承: 原型对象的属性和方法可以直接被实例对象所访问. 二. 原型链1. 理解原型链从第一部分的结论中我们知道了,实例对象可以直接访问原型对象的属性和方法. 其实原型对象本质上也是一个对象,它其实是由new Object()实例化出来的.该原型对象也可以访问Object.prototype的所有属性和方法.这样其实就构成了原型链这一个重要的概念. 2. 代码分析下面我们来分析以下一段代码12345678910111213141516171819202122232425//创建Product构造函数function Product ()&#123; this.name = 'apple';&#125;//给Product构造函数的原型增加方法Product.prototype.greet = function()&#123; console.log('我是一个很甜的'+ this.name +', 买我!');&#125;//创建SalesProduct构造函数function SalesProduct ()&#123; this.name = 'bad apple';&#125;//将Product的实例对象直接赋给SalesProduct的原型SalesProduct.prototype = new Product();//给SalesProduct的原型一个方法SalesProduct.prototype.anotherGreet = function()&#123; console.log('我是一个' + this.name + ',不要买我!');&#125;//实例化SalesProductvar p2 = new SalesProduct(); p2.greet(); //我是一个很甜的bad apple, 买我! ( 1 ) 在上面的代码中,我们没有使用SalesProduct默认提供的原型,而是将其换了一个新的原型.该新原型是Product的实例.( 2 ) 所以,该新原型不仅作为Product的实例拥有其全部属性和方法, 其内部还拥有一个指针,指向Product.prototype.我们可以从调用p2.greet()的结果可以看出.( 3 ) 所以,可以得出以下的链条 p2 =&gt; SalesProduct.prototype =&gt; Product.prototype =&gt; Object.prototype( 4 ) 上面的这一个链条就形成了原型链.值得注意的是,Product.prototype最后还指向了Object.prototype,这也是所有的自定义对象都会具有toString(),hasOwnProperty()等方法的原因. 3. 重要结论( 1 ) 原型的顶端: Object.prototype, 任何一个默认的内置的函数的原型都继承自Object.prototype.( 2 ) 原型链 : Js的对象结构中出现的指向Object.prototype的一系列原型对象,我们称之为原型链.( 3 ) 属性搜索原则 : 在访问对象的属性和方法时, 会在当前对象中查找, 如果没有找到, 会一直沿着原型链上的原型对象向上查找, 直到找到Object.prototype为止( 4 ) 写入原则 : 如果给对象设置属性和方法, 都是在当前对象上设置. 三. 实现继承的其他方法原型链继承是Javascript中实现继承的主要方式,但是原型链的继承存在一个问题,就是当对象有一个引用类型的属性时,该引用类型会被其后的所有实例所共享.下面的代码可以说明这一个问题.1234567891011121314function TypeOne()&#123; this.colors = ['red', 'blue', 'green']; &#125; function TypeTwo()&#123;&#125; TypeTwo.prototype = new TypeOne(); var t1 = new TypeTwo(); t1.colors.push('black'); console.log(t1.colors); //["red", "blue", "green", "black"] var t2 = new TypeTwo(); console.log(t2.colors); //["red", "blue", "green", "black"] 可以看,在t1这个实例中进行的colors这个属性的更改在t2这个实例中反映了出来.也就是说,所有的实例对象共享同一colors属性. 基于原型链继承的这一缺点,我们需要通过其他方式实现继承,下面来介绍几个常用的方法. 1. 借用构造函数在解决原型中包含引用类型值所带来问题的过程中, 开发人员开始使用一种叫借用构造函数的技术. 这种技术的基本思想相当简单, 即在子类型构造函数的内部调用超类型构造函数. 函数只不过是在特定环境中执行代码的对象, 因此, 通过使用apply()和call()方法可以在新创建的对象上执行构造函数,我们通过以下代码来解决上面的问题:12345678910111213141516function TypeOne()&#123; this.colors = ['red', 'blue', 'green'];&#125;function TypeTwo()&#123; TypeOne.call(this);&#125;TypeTwo.prototype = new TypeOne();var t1 = new TypeTwo();t1.colors.push('black');console.log(t1.colors); //["red", "blue", "green", "black"]var t2 = new TypeTwo();console.log(t2.colors); //["red", "blue", "green"] 2. 混入继承我们可以通过一个克隆函数extend(),将一组对象中的所有属性和方法克隆到一个对象中,这种实现继承的方法我们,我们将其称为混入继承.在jQuery的源码中,大量的采用了该方法.该克隆函数代码如下:123456789function extend (des, objs)&#123; for(var i = 0; i &lt; objs.length; i++)&#123; for(var key in objs[i])&#123; if(objs[i].hasOwnProperty(key))&#123; des[key] = objs[i][key]; &#125; &#125; &#125;&#125; 下面,我们通过该克隆函数实现三个对象中属性和方法继承到一个对象上:12345678910111213141516171819202122232425var o1 = &#123; name : &apos;Lee_Tanghui&apos;&#125;var o2 = &#123; sayHi: function ()&#123; console.log(&apos;你好,我是&apos; + this.name); &#125;&#125;var o3 = &#123; introduce: function ()&#123; console.log(&apos;我来自重庆&apos;); &#125;&#125;var obj = &#123;&#125;;//调用该方法实现让obj继承o1,o2,o3extend(obj, [o1, o2, o3]);console.log(obj.name); //Lee_Tanghuiobj.sayHi(); //你好,我是Lee_Tanghuiobj.introduce(); //我来自重庆 从上面的结果可以看到,obj对象继承了来o1,o2,o3的所有方法和属性. 3. 组合继承组合继承,指的是将原型链和借用构造函数的技术组合到一块. 从而发挥二者之长的一种继承模式. 其背后的思路是使用原型链实现对原型属性和方法的继承, 而通过借用构造函数来实现对实例属性的继承. 这样, 既通过在原型上定义方法实现了函数复用, 又能保证每个实例都有它自己的属性.我们可以通过以下代码来了解组合继承:12345678910111213141516171819202122232425262728293031function TypeOne(name)&#123; this.name = name; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;TypeOne.prototype.sayName = function()&#123; console.log(this.name);&#125;function TypeTwo(name, age)&#123; TypeOne.call(this, name); //通过构造函数实现对实例属性的继承 this.age = age;&#125;TypeTwo.prototype = new TypeOne(); //通过原型链实现对原型属性和方法的继承TypeTwo.prototype.sayAge = function() &#123; console.log(this.age);&#125;var t1 = new TypeTwo(&apos;Lee_Tanghui&apos;, 23);t1.colors.push(&apos;black&apos;);console.log(t1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]t1.sayName(); //Lee_Tanghuit1.sayAge(); //23var t2 = new TypeTwo(&apos;Joe&apos;, 24);console.log(t2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]t2.sayName(); //Joet2.sayAge(); //24 4. 原型式继承原型式继承是借助一个函数,通过传递原型对象作为参数,从而创建新对象的方式实现继承.该函数由道格拉斯提出,代码源码如下:12345function object(o) &#123; function F()&#123;&#125;; F.prototype = o; return new F();&#125; 在ECMAScript 5中新增加了Object.create()方法规范化了原型式继承.我们可以通过该方法实现将一下对象1234var person = &#123; name : 'joe', age : 24 &#125; 变为1[&#123;key: &quot;name&quot;, value: &quot;joe&quot; &#125;, &#123;key: &quot;age&quot;, value: 24&#125;]的数组的形式 代码实现如下12345678910111213141516171819202122var person = &#123; name : 'joe', age : 24,&#125;//创建构造函数,用来排列键值对function SortedList ( obj ) &#123; for ( var key in obj ) &#123; this.push(&#123; key : key, value : obj[ key ] &#125;) &#125;&#125;//调用Object.create()方法,继承数组的所有属性方法SortedList.prototype = Object.create( Array.prototype );//构造函数的实例化var list = new SortedList( person );console.log( list ); //[&#123;key: "name", value: "joe" &#125;, &#123;key: "age", value: 24&#125;] 完]]></content>
  </entry>
  <entry>
    <title><![CDATA[H5获取用户位置API + 百度地图API介绍]]></title>
    <url>%2F2017%2F06%2F26%2Flocation%2F</url>
    <content type="text"><![CDATA[一. Geolocaiton API 功能介绍 Geolocation接口是一个用来获取设备地理位置的可编程的对象,它可以让Web内容访问到设备的地理位置,这将允许Web应用基于用户的地理位置提供定制的信息. 出于安全考虑,当一个Web页尝试获取地理位置信息时, 会请求用户批准地理位置访问权限, 每个浏览器都有自己请求用户批准该权限的策略和方法. 二. Geolocaiton API 使用说明Geolocation API是通过window.navigator.geolocation获取地理定位的访问的,该对象有以下三个方法: 1. getCurrentPosition()1.1 语法1navigator.geolocation.getCurrentPosition(success,error,options) 1.2 参数说明 参数1.success: 必选参数,其作用是获取地理位置信息成功后返回执行的回调函数. 参数2.error:可选参数,作用是获取地理位置信息异常或失败时执行的回调函数. 参数3.options:可选参数,作用是添加一些可选参数设置 1.3 代码示例1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;地理定位&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //获取当前地理信息 window.navigator.geolocation.getCurrentPosition(success,error); //获取地理信息成功时的回调函数 function success(position) &#123; alert(&quot;成功获取您的地理信息&quot;); //获取经度维度信息 //coords属性 var latitude = position.coords.latitude; var longitude = position.coords.longitude; //打印纬度,经度信息 console.log(latitude); console.log(longitude); &#125; //获取地理信息失败时的回调函数 function error(msg) &#123; alert(&quot;获取您的地理信息失败&quot;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中,在获取地理位置信息成功时的回调函数中,可以传递pos这个参数对象,通过该参数对象,可以获得当前用户访问Web页面时的地理位置信息. pos对象包含一个coords属性,该属性表示一系列的地理位置信息: latitude: 以十进制数表示的纬度 longitude:以十进制数表示的经度 altitude:位置相对于椭圆球面的高度 accuracy: 以米为单位的纬度和经度坐标的精度水平 altitudeAccuracy:以米为单位的高度坐标精度水平 heading: 运动的方向,通过相对正北做顺时针旋转的角度指定. speed:以米/秒为单位的设备当前地面速度 2. watchPosition() 和 clearWatch()2.1 方法说明 watchPosition和 clearWatch是一对方法,其原理和setInterval,setTimeout方法相同, watchPositon方法会返回一个唯一标识,clearWatch可通过这个唯一标识清楚watchPosition方法的监听. 2.2 语法watchPosition()的语法和getCurrentPosition()一模一样,同样可以传入三个参数: 参数1.success: 必选参数,其作用是获取地理位置信息成功后返回执行的回调函数. 参数2.error:可选参数,作用是获取地理位置信息异常或失败时执行的回调函数. 参数3.options:可选参数,作用是添加一些可选参数设置 三.使用百度地图获取API接口3.1 百度地图API简介 百度地图API是为开发者免费提供的一套基于百度地图服务的应用接口，包括JavaScript API、Web服务API、Android SDK、iOS SDK、定位SDK、车联网API、LBS云等多种开发工具与服务，提供基本地图展现、搜索、定位、逆/地理编码、路线规划、LBS云存储与检索等功能，适用于PC端、移动端、服务器等多种设备，多种操作系统下的地图应用开发。 百度地图开放平台地址:http://lbsyun.baidu.com/ 3.2 JavaScript API 操作步骤1. 申请秘钥 为了统一平台服务的配额管理，JavaScript API在新版本引入ak机制。JavaScript API v1.4及以前版本无须申请密钥（ak），自v1.5版本开始需要先申请秘钥（ak），才可使用，如需获取更高配额，可申请认证企业用户。 申请秘钥的流程十分简单,和注册一个账号类似,只需要填入姓名,手机,和邮箱进行验证即可. 2. 选择Demo 百度地图API提供了一系列的功能,你可以根据需求选择对应的Demo,即可查看该Demo的API文档. 3. 引入JavaScript代码 在API文档中,可以在源代码编辑器中查看该Demo对应JavaScript代码,你只需要复制该JavaScript代码到您的代码编辑器中,添加&lt;script&gt;中的秘钥, 并根据其需求更改geolocation对象地理信息即可.]]></content>
  </entry>
  <entry>
    <title><![CDATA[2017年,前端应该学习的5个JavaScript框架]]></title>
    <url>%2F2017%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[前言 个人观点,供您参考 观点源自作者的使用经验和日常研究 排名基于框架的受欢迎度, 语法结构, 易用性等特性 希望大家能够基于此视频找到最适合自己的框架 下面介绍的都是严格的前端框架和库 Top5: PolymerPolymer是由谷歌Chorme组织内的前端开发团队领导的一个开源项目, 该项目的口号是: [UseThePlatform]. 团队相信, 拥抱现代Web平台是向用户和开发人员提供应用的最佳方式. 该producer介绍了Polymer的以下特性: Web组件:基于W3C标准的Web组件API. 使用原生浏览器的技术:Web组件内嵌于原生浏览器, 所以不需要像jQuery, dojo等第三方库 ,可以和其他Web组件无缝协作. Behaviors:其独有的Behaviors去分享Web组件和申明其属性. 封装:能够将代码和结构封装到相同位置. 自定义元素:开发人员能够自定义元素, 添加标签和属性 Top4: EmberEmber.js是一款开源的JavaScript MVC框架，用来创建Web应用程序。它免除了样板文件并提供了一套标准的应用程序架构。 项目口号是:「A framework for creating ambitious web applications」。 高效的生产力:其友好的API和符合人体工程学的设计理念, 使得开发人员能够快速完成构建工作 命名约定: Ember通过命名约定这种方式最少的节约代码的缩写 Ember-CLI: 开发Ember应用程序的官方命令行工具包,通过提供您在一个集成包中构建可生产就绪的Web应用程序所需的一切 丰富的插件: Ember提供丰富的插件,能够轻松的在应用程序之间共享通用代码 Handlebars集成模板: 能够在底层数据更改时自动更新, 可以大大减少代码量 Top3: AngularAngularJS最初由Misko Hevery 和Adam Abrons于2009年开发，后来成为了Google公司的项目。AngularJS弥补了HTML在构建应用方面的不足，其通过使用标识符（directives）结构，来扩展Web应用中的HTML词汇，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易. 全功能框架:具有HTML模块, 其特有的模块化, 自动化双向数据绑定, 语义化标签, 依赖注入等属性. 特别适合重量级的应用开发. 十分流行:首先它由Google维护. 其次是因为Angular是MEAN全堆栈的一部分 Angular CLI : 只需要掌握几条命令就可以构建Angular项目 TypeScript: Angular默认使用的TypeScript写,对喜欢TypeScript的开发者更加友好. 使用Ionic框架: Ionic框架被用来建立Hybrid App, 是目前最有潜力的一款HTML5手机应用开发框架. Top2: ReactReact 起源于 Facebook 的内部项目, 近年来,React从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案. React的理念是:[ Learn once, write everywhere] 轻量&amp;高效: 和Angular不同,React并不是全功能框架, 所以比较轻量. 虚拟DOM也使得拥有很好的性能表现. 十分火: 可以替代Angular成为MERN全堆栈的一部分. Flux&amp;Redux: 虽然React在视图层中运行,但是也可以使用Flux和Redux 创造响应式应用:React提供了响应式的视图组件和自有的命令行 移动端应用:Producer认为React是最好用的搭建移动端应用的框架 Top1: Vue.jsVue.js是一种渐进式的JavaScript框架. 与其他重量级框架不同的是,Vue 采用自底向上增量开发的设计.Vue 的核心库只关注视图层,它不仅易于上手,还便于与第三方库或既有项目整合. 简单: 比较其他框架,有着更友善的学习曲线, 只有使用者有基本的HTML和JavaScript知识, 都可以学习使用Vue 灵活 &amp; 生产性高: 在Vue2.0版本中添加了模板功能,其简单小巧的核心,渐进式的技术栈,可以应付所有应用. 速度快: Vue的虚拟DOM优化很好,速度十分的快,特别适合开发要求比较高的数据可视化和动画的应用中. v-model &amp; 2 way data binding: 可以使用v-model和2 way model进行数据绑定 Vue-CLI:Vue有自己的命令行,部署Vue比Angular简单很多. 本文内容来自Traversy Media频道中看到的视频内容,翻译后,供您参考! 原YouTube视频：Top 5 JavaScript Frameworks 2017 强烈推荐该YouTube频道 :Traversy Media]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端2017年学习路线指南]]></title>
    <url>%2F2017%2F05%2F10%2Fwebway%2F</url>
    <content type="text"><![CDATA[作为一名Web开发人员和设计师，到底应该在2017年学习什么技术？ 在本指南中，将讨论所有最新技术，告诉你如何正确的学习前端, 哪些知识是必须掌握的?哪些知识是可以作为补充学习的? 第一步: 掌握HTML/CSS 这是你最初必须掌握的 是网站的构建元素 没得选! 随着你前端的学习进程,熟练掌握 HTML/CSS简单易学 第二步: 使用基础工具 文本编辑器: Notepad2 / Sublime Text / Atom.io / IDE 图像编辑器:Photoshop, Illustrator, GIMP, Something slse FTP / SSH 工具 : Filezilla ,Putty 好的浏览器: Chrome 云盘: Dropbox, Google Drive, Box 第三步: 学习原生JavaScript 原生JavaScript(现阶段不需要理会Node.js 和任何框架) 理解数据类型: String, Number, Arrays, Objects, etc 理解函数, 条件表达式, 循环,操作符等 事件处理 JSON(JavaScript Object Notation), JavaScript对象表示法 jQuery框架 第四步:搭建一个基础网站: 获取一个虚拟主机账户(Hostgator, InMotion, etc) 学习虚拟主机控制系统基础——cPanel (Email ,FTP Setup) 通过FPT(文件传输协议)上传你的项目 创建域名并和你的主机连接 第五步:恭喜你! 你现在是一个网页设计师了!——(现阶段还不足以称Web Developer) 有能力搭建一个专业的简单网站 有能力搭建网页应用的界面 能够把一张PSD 转化为基于HTML/CSS的静态网页 有在公司上班的实力, 或者选择成为一名自由职业者 第六步: 思考接下来的侧重点! HTML/CSS框架: Bootstrap, Foudation(建议优先掌握!) 服务器端语言: PHP, Ruby…. JavaScript框架: React ,Angular 数据库: MySQL, PostgreSQL 第七步: HTML/CSS框架 Bootstrap(强烈推荐学习该框架!) Zurb Foundation Skeleton MUI Pure 第八步: 服务器端编程语言(专注于一个!) PHP(不是最好的语言,但是是最可靠的服务器端语言) Node.js(一款新型, 强大的后台语言) Ruby on Rails (最好的框架,但已经到了瓶颈期) Python(简单易学,但相对于主流语言并不流行)——可现在AI的爆红导致Python最近很火! 第九步: 数据库(专注于一个!) 关系型数据库: MySQL 和 PostgreSQL 非机构化数据库: MongoDB 和 CouchDB 建议选择一个以下的组合: PHP/ MySQL Node.js/ MongoDB 第十步: 需要学习的一些端技术 Git &amp; Github SSH(安全外壳协议) &amp; Basic Command Line CSS 预编译器: Sass/Less APIS / REST Service HTTPS / SSL 第十一步: 部署应用 专用服务器/ VPS 应用云平台: Heroku, Digital Ocean, AWS 部署工具 Linux命令行 维护和升级 第十二步:恭喜你,你现在成为一名网页开发者了! 能够创造出网页引用 能构建后端APIs 能连接服务器 能够管理数据库 你的选择: 得到一份很好的工作 / 成为自由职业者 / 开始一项事业 第十三步:编程框架 JavaScript框架: React, Angular 2, Vue.js, Express(后端) PHP框架: Laravel, Codeigniter, Symfony Ruby on rails MVC框架: Routing, Database Mapping, Helpers, Data Binding, Templating &amp; UI 第十四步: 内容管理系统(基于PHP) Wordpress(强烈推荐), Joomla, Drupal 有利用客户更新和维护 丰富的插件 开发速度快 模板的功能有限 第十五步: 移动App发展 这是未来的趋势 你不需要学习Java 和C语言! 你只需要掌握JavaScript!我们可以使用React Native, Ionic, Cordova 等框架来构建移动App 第十六步:现阶段,现在你需要考虑什么? 专注于你的事业 回去学习更多的数据结构 跟进现在的新技术 学习一门高级语言,类似于Java, C语言 以上内容来自我于在YouTube上看的一个视频, 感觉到很受用, 所以把视频的要点进行翻译,供您参考! 原YouTube视频：Web Development In 2017 - A Practical Guide 强烈推荐该YouTube频道 :Traversy Media]]></content>
  </entry>
</search>